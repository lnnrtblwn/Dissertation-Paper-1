ID = (((J - J_seq[1]) / my_by) * iter) + i
# ensure this is not overwritten for each J
result_prelim = simulation_factor(J, simu_type = simu_type)
results$Donors[ID] = J
results$bound_check[ID] = result_prelim$bound_check
results$rho_factor[ID] = result_prelim$rho_factor
results$rho_error[ID] = result_prelim$rho_error
results$PRE_SC_RMSPE[ID] = result_prelim$SC[1]
results$PRE_SC_BIAS[ID] = result_prelim$SC[2]
results$PRE_SC_VAR[ID] = result_prelim$SC[3]
results$POST_SC_RMSFE[ID] = result_prelim$SC[4]
results$POST_SC_BIAS[ID] = result_prelim$SC[5]
results$POST_SC_VAR[ID] = result_prelim$SC[6]
results$PRE_OLS_RMSPE[ID] = result_prelim$OLS[1]
results$PRE_OLS_BIAS[ID] = result_prelim$OLS[2]
results$PRE_OLS_VAR[ID] = result_prelim$OLS[3]
results$POST_OLS_RMSFE[ID] = result_prelim$OLS[4]
results$POST_OLS_BIAS[ID] = result_prelim$OLS[5]
results$POST_OLS_VAR[ID] = result_prelim$OLS[6]
results$PRE_REGOLS_RMSPE[ID] = result_prelim$REGOLS[1]
results$PRE_REGOLS_BIAS[ID] = result_prelim$REGOLS[2]
results$PRE_REGOLS_VAR[ID] = result_prelim$REGOLS[3]
results$POST_REGOLS_RMSFE[ID] = result_prelim$REGOLS[4]
results$POST_REGOLS_BIAS[ID] = result_prelim$REGOLS[5]
results$POST_REGOLS_VAR[ID] = result_prelim$REGOLS[6]
results$PRE_NET_RMSPE[ID] = result_prelim$NET[1]
results$PRE_NET_BIAS[ID] = result_prelim$NET[2]
results$PRE_NET_VAR[ID] = result_prelim$NET[3]
results$POST_NET_RMSFE[ID] = result_prelim$NET[4]
results$POST_NET_BIAS[ID] = result_prelim$NET[5]
results$POST_NET_VAR[ID] = result_prelim$NET[6]
results$PRE_FACTOR_RMSPE[ID] = result_prelim$FACTOR[1]
results$PRE_FACTOR_BIAS[ID] = result_prelim$FACTOR[2]
results$PRE_FACTOR_VAR[ID] = result_prelim$FACTOR[3]
results$POST_FACTOR_RMSFE[ID] = result_prelim$FACTOR[4]
results$POST_FACTOR_BIAS[ID] = result_prelim$FACTOR[5]
results$POST_FACTOR_VAR[ID] = result_prelim$FACTOR[6]
results$PRE_UNIDYN1_RMSPE[ID] = result_prelim$UNIDYN1[1]
results$PRE_UNIDYN1_BIAS[ID] = result_prelim$UNIDYN1[2]
results$PRE_UNIDYN1_VAR[ID] = result_prelim$UNIDYN1[3]
results$POST_UNIDYN1_RMSFE[ID] = result_prelim$UNIDYN1[4]
results$POST_UNIDYN1_BIAS[ID] = result_prelim$UNIDYN1[5]
results$POST_UNIDYN1_VAR[ID] = result_prelim$UNIDYN1[6]
results$PRE_UNIDYN2_RMSPE[ID] = result_prelim$UNIDYN2[1]
results$PRE_UNIDYN2_BIAS[ID] = result_prelim$UNIDYN2[2]
results$PRE_UNIDYN2_VAR[ID] = result_prelim$UNIDYN2[3]
results$POST_UNIDYN2_RMSFE[ID] = result_prelim$UNIDYN2[4]
results$POST_UNIDYN2_BIAS[ID] = result_prelim$UNIDYN2[5]
results$POST_UNIDYN2_VAR[ID] = result_prelim$UNIDYN2[6]
results$POST_OLSDIST_RMSFE[ID] = result_prelim$OLSDIST[1]
results$POST_OLSDIST_BIAS[ID] = result_prelim$OLSDIST[2]
results$POST_OLSDIST_VAR[ID] = result_prelim$OLSDIST[3]
# plots_REGOLS[[ID]] = result_prelim$Plots_REGOLS
# plots_UNIDYN1[[ID]] = result_prelim$Plots_UNIDYN1
# plots_UNIDYN2[[ID]] = result_prelim$Plots_UNIDYN2
# plots_OLSDIST[[ID]] = result_prelim$Plots_OLSDIST
rm(result_prelim)
svMisc::progress(ID, nrow(results))
}
}
# Lag for univariate dynamic case
p_uni = 3
# Group distribution of each factor
group_distribution = list(
"lambda1" = c(1,0),
"lambda2" = c(0,1))
# Specify intercept of treatment-unit. c(rnorm(1, mean = treat_inter, sd = 1), rnorm(J, mean = 0, sd = 1))
treat_inter = 0
# Number of pre-and post-treatment periods
T1 = 20
T0 = 50
# AR-Term in Factor model. y = c(y,intercept + rho*y[t]+rnorm(1,mean=0,sd = sqrt(var_shock)))
# rho = 0.8 // Non.Stationary => rho = 1.0
rho = 0.0
# Error AR-Term --> defined in my_functions
rho_u = runif(1, .5, 0.95)
# Intercept. Set it equal to mean*(1-rho) to define mean of process
alpha = 0*(1-rho)
# Specify variance of u_t. Set it to (1 - rho^2) will lead to var(\lambda^k_t) = 1. Variance of the factors
var_u = (1-rho^2)
# Specify variance of transitory shocks in Factor model equation. Variance of the error terms
var_epsilon = 1
# Post-treatment effects. Could be specified differently
post_effect = 10
# Number of factors
K = 2
# Adding a trend
#c = 0.02
c = 0
# Lag for univariate dynamic case
p_uni = 3
# Group distribution of each factor
group_distribution = list(
"lambda1" = c(1,0),
"lambda2" = c(0,1))
# Specify intercept of treatment-unit. c(rnorm(1, mean = treat_inter, sd = 1), rnorm(J, mean = 0, sd = 1))
treat_inter = 0
iter = 50
# J_max = min(round(T1 / 2.5,0), 70)
J_max = 30
CV_share = .5
my_by = 2
# J_seq = seq(5, J_max, by = my_by)
J_seq = c(5,10,15,20,25,30)
J_seq = c(2,4,6,8)
#J_seq = 3
# J = 5
# simu_type = 'Factor'
results = data.frame(matrix(NA, nrow = iter*length(J_seq), ncol = 1)) %>%
rename(Donors = c(1))
plots_UNIDYN1 = list()
plots_UNIDYN2 = list()
plots_REGOLS = list()
plots_OLSDIST = list()
# 2. SIMULATION ----
simu_type = "VAR"
p=3
for (J in J_seq) {
for (i in 1:iter) {
ID = (((J - J_seq[1]) / my_by) * iter) + i
# ensure this is not overwritten for each J
result_prelim = simulation_factor(J, simu_type = simu_type)
results$Donors[ID] = J
results$bound_check[ID] = result_prelim$bound_check
results$rho_factor[ID] = result_prelim$rho_factor
results$rho_error[ID] = result_prelim$rho_error
results$PRE_SC_RMSPE[ID] = result_prelim$SC[1]
results$PRE_SC_BIAS[ID] = result_prelim$SC[2]
results$PRE_SC_VAR[ID] = result_prelim$SC[3]
results$POST_SC_RMSFE[ID] = result_prelim$SC[4]
results$POST_SC_BIAS[ID] = result_prelim$SC[5]
results$POST_SC_VAR[ID] = result_prelim$SC[6]
results$PRE_OLS_RMSPE[ID] = result_prelim$OLS[1]
results$PRE_OLS_BIAS[ID] = result_prelim$OLS[2]
results$PRE_OLS_VAR[ID] = result_prelim$OLS[3]
results$POST_OLS_RMSFE[ID] = result_prelim$OLS[4]
results$POST_OLS_BIAS[ID] = result_prelim$OLS[5]
results$POST_OLS_VAR[ID] = result_prelim$OLS[6]
results$PRE_REGOLS_RMSPE[ID] = result_prelim$REGOLS[1]
results$PRE_REGOLS_BIAS[ID] = result_prelim$REGOLS[2]
results$PRE_REGOLS_VAR[ID] = result_prelim$REGOLS[3]
results$POST_REGOLS_RMSFE[ID] = result_prelim$REGOLS[4]
results$POST_REGOLS_BIAS[ID] = result_prelim$REGOLS[5]
results$POST_REGOLS_VAR[ID] = result_prelim$REGOLS[6]
results$PRE_NET_RMSPE[ID] = result_prelim$NET[1]
results$PRE_NET_BIAS[ID] = result_prelim$NET[2]
results$PRE_NET_VAR[ID] = result_prelim$NET[3]
results$POST_NET_RMSFE[ID] = result_prelim$NET[4]
results$POST_NET_BIAS[ID] = result_prelim$NET[5]
results$POST_NET_VAR[ID] = result_prelim$NET[6]
results$PRE_FACTOR_RMSPE[ID] = result_prelim$FACTOR[1]
results$PRE_FACTOR_BIAS[ID] = result_prelim$FACTOR[2]
results$PRE_FACTOR_VAR[ID] = result_prelim$FACTOR[3]
results$POST_FACTOR_RMSFE[ID] = result_prelim$FACTOR[4]
results$POST_FACTOR_BIAS[ID] = result_prelim$FACTOR[5]
results$POST_FACTOR_VAR[ID] = result_prelim$FACTOR[6]
results$PRE_UNIDYN1_RMSPE[ID] = result_prelim$UNIDYN1[1]
results$PRE_UNIDYN1_BIAS[ID] = result_prelim$UNIDYN1[2]
results$PRE_UNIDYN1_VAR[ID] = result_prelim$UNIDYN1[3]
results$POST_UNIDYN1_RMSFE[ID] = result_prelim$UNIDYN1[4]
results$POST_UNIDYN1_BIAS[ID] = result_prelim$UNIDYN1[5]
results$POST_UNIDYN1_VAR[ID] = result_prelim$UNIDYN1[6]
results$PRE_UNIDYN2_RMSPE[ID] = result_prelim$UNIDYN2[1]
results$PRE_UNIDYN2_BIAS[ID] = result_prelim$UNIDYN2[2]
results$PRE_UNIDYN2_VAR[ID] = result_prelim$UNIDYN2[3]
results$POST_UNIDYN2_RMSFE[ID] = result_prelim$UNIDYN2[4]
results$POST_UNIDYN2_BIAS[ID] = result_prelim$UNIDYN2[5]
results$POST_UNIDYN2_VAR[ID] = result_prelim$UNIDYN2[6]
results$POST_OLSDIST_RMSFE[ID] = result_prelim$OLSDIST[1]
results$POST_OLSDIST_BIAS[ID] = result_prelim$OLSDIST[2]
results$POST_OLSDIST_VAR[ID] = result_prelim$OLSDIST[3]
# plots_REGOLS[[ID]] = result_prelim$Plots_REGOLS
# plots_UNIDYN1[[ID]] = result_prelim$Plots_UNIDYN1
# plots_UNIDYN2[[ID]] = result_prelim$Plots_UNIDYN2
# plots_OLSDIST[[ID]] = result_prelim$Plots_OLSDIST
rm(result_prelim)
svMisc::progress(ID, nrow(results))
}
}
library(tidyverse)
library(gridExtra)
library(tidyverse)
library(gridExtra)
rm(list = ls())
if (Sys.info()[6] == "jctoe"){
setwd("C:/Promotion/SC_Paper/")
} else {
setwd("~/Diss/Topics/Synthetic Control/")
}
source("Documents/sc_sim Ferman/Ferman/my_functions.R")
source("Chunks/Simulations/07 - VAR_simu_GDP.R")
#set.seed(052023)
# 1. DATA GENERATING PROCESS: FACTOR MODEL WITHOUT COVARIATES ----
# Number of pre-and post-treatment periods
T1 = 20
T0 = 50
# AR-Term in Factor model. y = c(y,intercept + rho*y[t]+rnorm(1,mean=0,sd = sqrt(var_shock)))
# rho = 0.8 // Non.Stationary => rho = 1.0
rho = 0.0
# Error AR-Term --> defined in my_functions
rho_u = runif(1, .5, 0.95)
# Intercept. Set it equal to mean*(1-rho) to define mean of process
alpha = 0*(1-rho)
# Specify variance of u_t. Set it to (1 - rho^2) will lead to var(\lambda^k_t) = 1. Variance of the factors
var_u = (1-rho^2)
# Specify variance of transitory shocks in Factor model equation. Variance of the error terms
var_epsilon = 1
# Post-treatment effects. Could be specified differently
post_effect = 10
# Number of factors
K = 2
# Adding a trend
#c = 0.02
c = 0
# Lag for univariate dynamic case
p_uni = 3
# Group distribution of each factor
group_distribution = list(
"lambda1" = c(1,0),
"lambda2" = c(0,1))
# Specify intercept of treatment-unit. c(rnorm(1, mean = treat_inter, sd = 1), rnorm(J, mean = 0, sd = 1))
treat_inter = 0
iter = 50
# J_max = min(round(T1 / 2.5,0), 70)
J_max = 30
CV_share = .5
my_by = 2
# J_seq = seq(5, J_max, by = my_by)
J_seq = c(5,10,15,20,25,30)
J_seq = c(2,4,6,8)
#J_seq = 3
# J = 5
# simu_type = 'Factor'
results = data.frame(matrix(NA, nrow = iter*length(J_seq), ncol = 1)) %>%
rename(Donors = c(1))
plots_UNIDYN1 = list()
plots_UNIDYN2 = list()
plots_REGOLS = list()
plots_OLSDIST = list()
# 2. SIMULATION ----
simu_type = "VAR"
p=3
for (J in J_seq) {
for (i in 1:iter) {
ID = (((J - J_seq[1]) / my_by) * iter) + i
# ensure this is not overwritten for each J
result_prelim = simulation_factor(J, simu_type = simu_type)
results$Donors[ID] = J
results$bound_check[ID] = result_prelim$bound_check
results$rho_factor[ID] = result_prelim$rho_factor
results$rho_error[ID] = result_prelim$rho_error
results$PRE_SC_RMSPE[ID] = result_prelim$SC[1]
results$PRE_SC_BIAS[ID] = result_prelim$SC[2]
results$PRE_SC_VAR[ID] = result_prelim$SC[3]
results$POST_SC_RMSFE[ID] = result_prelim$SC[4]
results$POST_SC_BIAS[ID] = result_prelim$SC[5]
results$POST_SC_VAR[ID] = result_prelim$SC[6]
results$PRE_OLS_RMSPE[ID] = result_prelim$OLS[1]
results$PRE_OLS_BIAS[ID] = result_prelim$OLS[2]
results$PRE_OLS_VAR[ID] = result_prelim$OLS[3]
results$POST_OLS_RMSFE[ID] = result_prelim$OLS[4]
results$POST_OLS_BIAS[ID] = result_prelim$OLS[5]
results$POST_OLS_VAR[ID] = result_prelim$OLS[6]
results$PRE_REGOLS_RMSPE[ID] = result_prelim$REGOLS[1]
results$PRE_REGOLS_BIAS[ID] = result_prelim$REGOLS[2]
results$PRE_REGOLS_VAR[ID] = result_prelim$REGOLS[3]
results$POST_REGOLS_RMSFE[ID] = result_prelim$REGOLS[4]
results$POST_REGOLS_BIAS[ID] = result_prelim$REGOLS[5]
results$POST_REGOLS_VAR[ID] = result_prelim$REGOLS[6]
results$PRE_NET_RMSPE[ID] = result_prelim$NET[1]
results$PRE_NET_BIAS[ID] = result_prelim$NET[2]
results$PRE_NET_VAR[ID] = result_prelim$NET[3]
results$POST_NET_RMSFE[ID] = result_prelim$NET[4]
results$POST_NET_BIAS[ID] = result_prelim$NET[5]
results$POST_NET_VAR[ID] = result_prelim$NET[6]
results$PRE_FACTOR_RMSPE[ID] = result_prelim$FACTOR[1]
results$PRE_FACTOR_BIAS[ID] = result_prelim$FACTOR[2]
results$PRE_FACTOR_VAR[ID] = result_prelim$FACTOR[3]
results$POST_FACTOR_RMSFE[ID] = result_prelim$FACTOR[4]
results$POST_FACTOR_BIAS[ID] = result_prelim$FACTOR[5]
results$POST_FACTOR_VAR[ID] = result_prelim$FACTOR[6]
results$PRE_UNIDYN1_RMSPE[ID] = result_prelim$UNIDYN1[1]
results$PRE_UNIDYN1_BIAS[ID] = result_prelim$UNIDYN1[2]
results$PRE_UNIDYN1_VAR[ID] = result_prelim$UNIDYN1[3]
results$POST_UNIDYN1_RMSFE[ID] = result_prelim$UNIDYN1[4]
results$POST_UNIDYN1_BIAS[ID] = result_prelim$UNIDYN1[5]
results$POST_UNIDYN1_VAR[ID] = result_prelim$UNIDYN1[6]
results$PRE_UNIDYN2_RMSPE[ID] = result_prelim$UNIDYN2[1]
results$PRE_UNIDYN2_BIAS[ID] = result_prelim$UNIDYN2[2]
results$PRE_UNIDYN2_VAR[ID] = result_prelim$UNIDYN2[3]
results$POST_UNIDYN2_RMSFE[ID] = result_prelim$UNIDYN2[4]
results$POST_UNIDYN2_BIAS[ID] = result_prelim$UNIDYN2[5]
results$POST_UNIDYN2_VAR[ID] = result_prelim$UNIDYN2[6]
results$POST_OLSDIST_RMSFE[ID] = result_prelim$OLSDIST[1]
results$POST_OLSDIST_BIAS[ID] = result_prelim$OLSDIST[2]
results$POST_OLSDIST_VAR[ID] = result_prelim$OLSDIST[3]
# plots_REGOLS[[ID]] = result_prelim$Plots_REGOLS
# plots_UNIDYN1[[ID]] = result_prelim$Plots_UNIDYN1
# plots_UNIDYN2[[ID]] = result_prelim$Plots_UNIDYN2
# plots_OLSDIST[[ID]] = result_prelim$Plots_OLSDIST
rm(result_prelim)
svMisc::progress(ID, nrow(results))
}
}
if (simu_type == 'Factor'){
# print TS-structure in results-frame
results = list()
#rho_u = runif(1, .5, 0.95)
rho_u = 0
Mu = matrix(0, nrow = J+1, ncol = K)
for(k in 1:K) {
fac_distr = group_distribution[[k]]
for(pos in 1:length(fac_distr))
if(pos==1)
Mu[1:(1 + J %/% length(fac_distr)),k] = fac_distr[pos] else
if (pos < length(fac_distr))
Mu[(2 + (pos - 1)*J %/% length(fac_distr)):(1 + pos * J %/% length(fac_distr)),k] = fac_distr[pos] else
Mu[(2+(pos-1)*J%/%length(fac_distr)):nrow(Mu),k] = fac_distr[pos]
}
Factors = sapply(1:K, function(k){simulate_ar1(rho = rho, var_shock = var_u, T0 = T0+T1, intercept = alpha)})
# AR(1) shocks
transitory_shocks = sapply(1:dim(Mu)[1], function(k){simulate_ar1(rho = rho_u, var_shock = 1, T0 = T0+T1, intercept = 0)})
#Stationary Shocks
#transitory_shocks = matrix(rnorm((J+1)*(T0+T1), sd = sqrt(var_epsilon)), nrow = (T0+T1), ncol = J+1)
y = Factors%*%t(Mu) + transitory_shocks
y = y + (1:nrow(y))^1.5*c
} else {
est_coefs = VAR_est(J=J, p = p)
stat_test = Stat_test(est_coefs)
y = tail(VAR_simu(est_coefs),(T0+T1))
while (stat_test > 0.99) {
est_coefs = VAR_est(J=J, p = p)
stat_test = Stat_test(est_coefs)
y = tail(VAR_simu(est_coefs),(T0+T1))
}
}
# Define Series specific intercepts for Factor Simu
if (simu_type == 'Factor'){
# curve(dnorm(x, 0, 10), from=-4, to=4)
my_means = c(rnorm(1, mean = treat_inter, sd = 1), rnorm(J, mean = 0, sd = 1))
# interval check: 1 if treated series within donor series, 0 if not.
# results[["bound_check"]] = ifelse(my_means[1] > min(my_means[c(FALSE, Mu[-1,1] == 1)]) &
#                                my_means[1] < max(my_means[c(FALSE, Mu[-1,1] == 1)]),
#                              1, 0)
# Das macht an dieser Stelle doch gar keinen Sinn? Die Means werden doch erst unten addiert. Nach unten kopiert
# results[["bound_check"]] = as.numeric(rank(colMeans(y))[1])
for (i in 1:J) {
y[,i] = y[,i] + my_means[i]
}
results[["bound_check"]] = as.numeric(rank(colMeans(y))[1])
} else {
# if (colMeans(y)[1] > max(colMeans(y)[-1])) {results[["bound_check"]] = 1
# } else if (colMeans(y)[1] < min(colMeans(y)[-1])) {results[["bound_check"]] = -1
# } else {results[["bound_check"]] = 0}
results[["bound_check"]] = as.numeric(rank(colMeans(y))[1])
}
# Adding effect
y[(T0+1):(T0+T1),1] = post_effect + y[(T0+1):(T0+T1),1]
y_pre = y[1:T0,1]
y_post = y[(T0+1):(T0+T1),1]
x_pre = y[1:T0, -1]
x_post = y[(T0+1):(T0+T1), -1]
results[["rho_factor"]] = rho
results[["rho_error"]] = rho_u
# SC
Dmat = t(x_pre) %*% x_pre
dvec = t(x_pre) %*% y_pre
Amat = t(rbind(rep(1, ncol(x_pre)), diag(ncol(x_pre)), -1*diag(ncol(x_pre))))
bvec = c(1, rep(0, ncol(x_pre)), rep(-1,ncol(x_pre)))
synth_model = tryCatch({
quadprog::solve.QP(Dmat, dvec, Amat, bvec, meq = 1)},
error = function(e) {
# Return a default value to indicate failure
return(NA)
})
if (any(is.na(synth_model))) {
y_sc_pre = rep(NA, T0)
y_sc_post = rep(NA, T1)
} else {
w_sc = synth_model$solution
y_sc_pre = x_pre %*% w_sc
y_sc_post = x_post %*% w_sc}
y_treat_sc = as.data.frame(c(y_pre, y_post)) %>%
rename(y = c(1))
y_treat_sc$y_hat = c(y_sc_pre, y_sc_post)
results_SC = c()
results_SC["PRE_SC_RMSPE"] = sqrt(mean((y_pre - y_sc_pre)^2))
results_SC["PRE_SC_BIAS"] = mean(y_sc_pre - y_pre)
results_SC["PRE_SC_VAR"] = mean((y_sc_pre - mean(y_sc_pre))^2)
results_SC["POST_SC_RMSFE"] = sqrt(mean(((y_post-post_effect) - y_sc_post)^2))
results_SC["POST_SC_BIAS"] = mean(y_sc_post - (y_post-post_effect))
results_SC["POST_SC_VAR"] = mean((y_sc_post - mean(y_sc_post))^2)
results[["SC"]] = results_SC
results_SC
results
results = data.frame(matrix(NA, nrow = iter*length(J_seq), ncol = 1)) %>%
rename(Donors = c(1))
results
results_SC
results[["SC"]] = results_SC
# Number of pre-and post-treatment periods
T1 = 20
T0 = 50
# AR-Term in Factor model. y = c(y,intercept + rho*y[t]+rnorm(1,mean=0,sd = sqrt(var_shock)))
# rho = 0.8 // Non.Stationary => rho = 1.0
rho = 0.0
# Error AR-Term --> defined in my_functions
rho_u = runif(1, .5, 0.95)
# Intercept. Set it equal to mean*(1-rho) to define mean of process
alpha = 0*(1-rho)
# Specify variance of u_t. Set it to (1 - rho^2) will lead to var(\lambda^k_t) = 1. Variance of the factors
var_u = (1-rho^2)
# Specify variance of transitory shocks in Factor model equation. Variance of the error terms
var_epsilon = 1
# Post-treatment effects. Could be specified differently
post_effect = 10
# Number of factors
K = 2
# Adding a trend
#c = 0.02
c = 0
# Lag for univariate dynamic case
p_uni = 3
# Group distribution of each factor
group_distribution = list(
"lambda1" = c(1,0),
"lambda2" = c(0,1))
# Specify intercept of treatment-unit. c(rnorm(1, mean = treat_inter, sd = 1), rnorm(J, mean = 0, sd = 1))
treat_inter = 0
iter = 50
# J_max = min(round(T1 / 2.5,0), 70)
J_max = 30
CV_share = .5
my_by = 2
# J_seq = seq(5, J_max, by = my_by)
J_seq = c(5,10,15,20,25,30)
J_seq = c(2,4,6,8)
#J_seq = 3
J_seq = 3
results = data.frame(matrix(NA, nrow = iter*length(J_seq), ncol = 1)) %>%
rename(Donors = c(1))
plots_UNIDYN1 = list()
plots_UNIDYN2 = list()
plots_REGOLS = list()
plots_OLSDIST = list()
simu_type = "VAR"
p=3
for (J in J_seq) {
for (i in 1:iter) {
ID = (((J - J_seq[1]) / my_by) * iter) + i
# ensure this is not overwritten for each J
result_prelim = simulation_factor(J, simu_type = simu_type)
results$Donors[ID] = J
results$bound_check[ID] = result_prelim$bound_check
results$rho_factor[ID] = result_prelim$rho_factor
results$rho_error[ID] = result_prelim$rho_error
results$PRE_SC_RMSPE[ID] = result_prelim$SC[1]
results$PRE_SC_BIAS[ID] = result_prelim$SC[2]
results$PRE_SC_VAR[ID] = result_prelim$SC[3]
results$POST_SC_RMSFE[ID] = result_prelim$SC[4]
results$POST_SC_BIAS[ID] = result_prelim$SC[5]
results$POST_SC_VAR[ID] = result_prelim$SC[6]
results$PRE_OLS_RMSPE[ID] = result_prelim$OLS[1]
results$PRE_OLS_BIAS[ID] = result_prelim$OLS[2]
results$PRE_OLS_VAR[ID] = result_prelim$OLS[3]
results$POST_OLS_RMSFE[ID] = result_prelim$OLS[4]
results$POST_OLS_BIAS[ID] = result_prelim$OLS[5]
results$POST_OLS_VAR[ID] = result_prelim$OLS[6]
results$PRE_REGOLS_RMSPE[ID] = result_prelim$REGOLS[1]
results$PRE_REGOLS_BIAS[ID] = result_prelim$REGOLS[2]
results$PRE_REGOLS_VAR[ID] = result_prelim$REGOLS[3]
results$POST_REGOLS_RMSFE[ID] = result_prelim$REGOLS[4]
results$POST_REGOLS_BIAS[ID] = result_prelim$REGOLS[5]
results$POST_REGOLS_VAR[ID] = result_prelim$REGOLS[6]
results$PRE_NET_RMSPE[ID] = result_prelim$NET[1]
results$PRE_NET_BIAS[ID] = result_prelim$NET[2]
results$PRE_NET_VAR[ID] = result_prelim$NET[3]
results$POST_NET_RMSFE[ID] = result_prelim$NET[4]
results$POST_NET_BIAS[ID] = result_prelim$NET[5]
results$POST_NET_VAR[ID] = result_prelim$NET[6]
results$PRE_FACTOR_RMSPE[ID] = result_prelim$FACTOR[1]
results$PRE_FACTOR_BIAS[ID] = result_prelim$FACTOR[2]
results$PRE_FACTOR_VAR[ID] = result_prelim$FACTOR[3]
results$POST_FACTOR_RMSFE[ID] = result_prelim$FACTOR[4]
results$POST_FACTOR_BIAS[ID] = result_prelim$FACTOR[5]
results$POST_FACTOR_VAR[ID] = result_prelim$FACTOR[6]
results$PRE_UNIDYN1_RMSPE[ID] = result_prelim$UNIDYN1[1]
results$PRE_UNIDYN1_BIAS[ID] = result_prelim$UNIDYN1[2]
results$PRE_UNIDYN1_VAR[ID] = result_prelim$UNIDYN1[3]
results$POST_UNIDYN1_RMSFE[ID] = result_prelim$UNIDYN1[4]
results$POST_UNIDYN1_BIAS[ID] = result_prelim$UNIDYN1[5]
results$POST_UNIDYN1_VAR[ID] = result_prelim$UNIDYN1[6]
results$PRE_UNIDYN2_RMSPE[ID] = result_prelim$UNIDYN2[1]
results$PRE_UNIDYN2_BIAS[ID] = result_prelim$UNIDYN2[2]
results$PRE_UNIDYN2_VAR[ID] = result_prelim$UNIDYN2[3]
results$POST_UNIDYN2_RMSFE[ID] = result_prelim$UNIDYN2[4]
results$POST_UNIDYN2_BIAS[ID] = result_prelim$UNIDYN2[5]
results$POST_UNIDYN2_VAR[ID] = result_prelim$UNIDYN2[6]
results$POST_OLSDIST_RMSFE[ID] = result_prelim$OLSDIST[1]
results$POST_OLSDIST_BIAS[ID] = result_prelim$OLSDIST[2]
results$POST_OLSDIST_VAR[ID] = result_prelim$OLSDIST[3]
# plots_REGOLS[[ID]] = result_prelim$Plots_REGOLS
# plots_UNIDYN1[[ID]] = result_prelim$Plots_UNIDYN1
# plots_UNIDYN2[[ID]] = result_prelim$Plots_UNIDYN2
# plots_OLSDIST[[ID]] = result_prelim$Plots_OLSDIST
rm(result_prelim)
svMisc::progress(ID, nrow(results))
}
}
results_SC
results[["REGOLS"]]
results_REGOLS
